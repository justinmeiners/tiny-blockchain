# Write your own Blockchain


@code_type c .c
@comment_type /* %s */
@add_css main.css

@title Write your Own Proof-of-Work Blockchain

@s

By: [**Justin Meiners**](https://github.com/justinmeiners).

View the final code and other resources in the [GitHub repo](https://github.com/justinmeiners/tiny-blockchain).

@s Introduction

This article will teach you how to write a tiny proof-of-work blockchain,
focusing on the Bitcoin implementation.
I emphasize "proof-of-work" because as we shall see, this is the key innovation that allows Bitcoin
to store information in an "objectively" verifiable way.
I wrote this mainly for programmers who are curious about how cryptocurrency works.
If you are already an enthusist you probably have seen similar articles.
I hope to bring a valuable perspective by focusing on the essentials.

This project will be written in C, although it is easy to translate to other languages.
To start, create a new `.c` file for the code in the article.
You will also need to include [sha-256.h](src/sha-256.h) and [sha-256.c](src/sha-256.c) for
hashes (or use your language's library).

> **Note:** This is a [literate program](https://en.wikipedia.org/wiki/Literate_programming).
> This means you are reading the source code right now!
> The final output was created by ["weaving"](https://github.com/zyedidia/Literate) the blocks of code together.

@s Hash Review

You are probably familiar with [hashes](https://en.wikipedia.org/wiki/Cryptographic_hash_function), but just to review
a hash is a function which maps large pieces of data to short checksums.
The essential property of a hash is that it's *one way*.
It's *easy* to calculate output for an input, *impossible* to know
what input produced a given output, and
*very difficult* to find an alternative piece of data
that produces the same output.

![hash function](img/hash.png)

To verify a piece of data, hash it and compare it with a trusted hash.
Since it's extremely unlikely that different data hashes the same,
if they match, we have good reason to believe that the data is valid.

For example, a newspaper could publish the hash of each paper it publishes,
so that anyone could verify whether a given paper was valid.
Ubuntu publishes the hash of each release, so you know you downloaded the real thing, and 
not a virus.
(Of course, you still have to trust that the hash you got is the right one.)

To check your knowledge of hashes, here are some questions to consider:

- Must every possible hash be mapped to?
- Could there be a hash that only one thing maps to? In other words
  only a single input could produce it?
- Why is there at least one hash that infinitely many things map to?

@s What is a blockchain?

Hash checksums are helpful for verifying the *state* of data,
at a fixed snapshot in time.
But, sometimes we want to check the *history* of some data over time.
Two pieces of data which are the same now, may not be equivalent if
they took different paths to get there.

A bank account is one such example.
We not only care about the final balance, but the full history of each individual
deposit and withdrawel.
Did our bills get paid?
Has someone been withdrawing money from our account?
Historical integrity here is essential!
Note that a hash of a bank statement is worthless,
even if it includes the full record of transactions.
As soon as a new transaction comes in, the hash
must completely change.
Someone could just as easily tamper with past transactions,
and the hash couldn't tell you.

A blockchain allows us to verify these kinds of histories.
In physics and math this property is called [path dependence](https://en.wikipedia.org/wiki/Nonholonomic_system)
which leads us to a very philosphical definition:
a blockchain is a tool for verifying the integrity of path dependent systems.
Just kidding! 
That's not very helpful. How about this:

A blockchain is a data structure for storing an ordered sequence of records (**blocks**) in a tamper-resistant way.
Given some small header information one can verify whether a given record:

1. has been modified
2. belongs in the sequence
3. is in the correct order, relative to the other records

Each block is made up of a **header** and **contents**.
The **contents** are just arbitrary data to be stored in the chain.
The **header** contains some info about the block and two hashes:

1. The hash of the contents.

2. The hash of the previous block header.
   This ensures that anyone with the header
   can also check that *no preceding* block has changed.

--- block header
typedef struct
{
    /* Length of the data in the block */
    uint32_t contents_length;
    /* Hash of the block contents.
       Prevents contents from changing
       (in Bitcoin this would actually be the "merkle root" */
    uint8_t contents_hash[32];
    /* prevents previous data from changing */
    uint8_t previous_hash[32];

    @{proof-of-work entries}
} block_header_t;

---

(`32` is then number of bytes in a `sha256` hash.)

The headers then form a chain by linking each header to the previous.

![blockchain](img/blockchain.gif)

Applying this to the bank account example, each day's transactions
could be stored in a block.
Given the hash of the last header in the chain, (such as a bank statement)
new transactions could be added in new blocks,
but no changes could be made to any previous block
, without disrupting the hash.
Because each header reference the previous block,
and that one references the one *before it*,
changes propogate like dominos knocking each other over.

The domino effect can also be seen in the expanded equation for the hash of the last block
where $h$ is a hash function and $C_{i}$ is the contents. See how it includes the contents of each preceding block?

$$h(h(h(\ldots \oplus C_{n-2}) \oplus C_{n-1}) \oplus C_n)$$

If you use Git version control, you are already familiar with this!
Each commit is a hash of the state of the code, and also the hash
of the previous commit.
If you change an old commit, all future commits change.
Just like the bank account example,
the history of the code matters just as much as the state.
so that differing histories result in different commit hashes.

@s Creating Blocks

The Bitcoin blockchain works just like a bank account.
It stores a ledger of [financial transactions](https://en.bitcoin.it/wiki/Transaction).
But, blockchains can store any kind of data.
In this project we will be storing blobs of text.

Creating a block and adding it to the chain is very straightfoward.
The block also needs a reference to a previous block header (or `NULL` for the "genesis" block.)
We simply hash the contents and the previous block header and 
assign it to the new header.

--- build block
block_header_t build_block(const block_header_t* previous, const char* contents, uint64_t length)
{
    block_header_t header;
    header.contents_length = length;

    if (previous)
    {
        /* calculate previous block header hash */
        calc_sha_256(header.previous_hash, previous, sizeof(block_header_t));
    }
    else
    {
        /* genesis has no previous. just use zeroed hash */
        memset(header.previous_hash, 0, sizeof(header.previous_hash));
    }
    
    /* add data hash */
    calc_sha_256(header.contents_hash, contents, length);

    /* mining. disucssed later */
    mine_block(&header);
    return header;
}
---

@s What is proof-of-work?

Blockchains can effectively store
records over time, but the headers must always
be obtained by a trusted party, whether 
it's yourself or your bank.
To verify a block, you need the headers.
If you don't already have them, a malicious person could give you fake headers,
and you would have no way to tell they weren't *genuine*.
They could also add new headers to a blockchain
you trust and the new ones would look just as valid as the old one!

So, blockchains can be useful record keeping tools among trusted groups, but its not clear
at this point how they can keep any kind of contested record.
The challenge posed by Bitcoin is to store a record of financial 
transactions that everyone can agree on.
We shouldn't have to trust another person to keep those records safe.
This is the problem solved by **proof-of-work**. 
It provides a simple rule that anyone can use to "objectively" determine
whether a given blockchain is the "right" one.

Instead of allowing blocks to be created freely,
proof-of-work requires that CPU resources be spent on a problem first.
This process is called **mining**.
Proof that the CPU resources were spent 
is included in the block itself, so that
anyone can verify that the work was actually done.
Hence the term "proof-of-work".

This limits the rate at which blocks can be produced to the speed of CPUs.
In the Bitcoin network, computers across the world
are constantly racing to be the first to solve a problem
so they can produce a block.
But the difficulty of the problem ensures that it will 
take a certain amount of time, before anyone can produce a block,
and so adds an additional property:
*longer chains have had more CPU resources spent making them.*

This is what makes the chain verifiable.
The valid Bitcoin chain is always *the one that is the longest*
because it is the one that has had the most mining effort
spent on it.

> "Proof-of-work is essentially one-CPU-one-vote.
> The majority decision is represented by the longest chain,
> which has the greatest proof-of-work effort invested in it." - Satoshi Nakamoto

Proof-of-work also makes it very difficult to tamper with old records or make a fake chain.
In order to rewrite a chain, you have to spend the CPU resources
to do so.
To go back two blocks, double the amount of work must be done, and 
so on.
Meanwhile, the original chain is constantly being extended by CPUs across the globe.

I put the words "objectively" and "right" in quotes because you now 
know those claims are a bit dubious.
The "right" chain is defined by a consensues of CPU power.
A group or individual who wields a lot of CPU power can change tehe consensus.
The right one is the one that the most mining power has been put into.
The only objective thing we know is which chain has had the most CPU
resources spent on it.

> "Bitcoin can thus be understood as a technology that converts electricity to truthful records through the expenditure of processing power." - Safedean Ammous.

@s Mining

To add proof-of-work, we add an additional requirement to the chain,
which is that the hash of any block header must be less than
some **target** hash.
In other words $h(header) < T$.
By "less than" we mean the usual [byte by byte](https://en.cppreference.com/w/c/string/byte/memcmp) lexographic
comparsion, like alphabetical order.
(For example `0000 0001` is less than `0000 0010`)

### Target

The target `T` can be any hash. However, the smaller (in ordering) it is
, the more difficult it is to find a valid hash, because there
are a fewer hashes within the valid range.

The target may be different for each block.
This allows Bitcoin to adjust mining difficulty to adapt
to improving CPUs.
But in our project we will use a constant target.

--- target
/* this controls the difficulty.
   I chose this target because it works well on my computer.
   feel free to try out others. */

uint8_t target[32];
memset(target, 0, sizeof(target));
target[2] = 0x0F;

/* too hard?: try target[2] = 0xFF
   too easy?: try target[2] = 0x01 */
---

### Nonce

Right now the header is fixed, it contains only two immutable fields,
the contents hash, and the previous block hash.
So how can we get a hash below the target? 
We need to add a few additional fields to the headers.
These are called the **nonce** and **timestamp**.

Add the following to the `block_header_t` struct from before.

--- proof-of-work entries
/* when this block started being mined */
uint32_t timestamp; 

/* nonce.
   this is adjusted by the miner,
   until a suitable hash is found */
uint32_t nonce;
---

To make a block header valid, the nonce
is adjusted until the header hashes in the valid range.
This adjustment process is the difficult problem referred to earlier.
It's really hard to find a valid hash.
There is no rhyme or reason to guessing the nonce.
The miner just tries as many as it can!

Let's write a loop that just tests numbers in order:
(It will be placed in a mining function below.)

--- nonce search
/* adjust the nonce until the block header is < the target hash */
uint8_t block_hash[32];

for (uint32_t i = 0; i < UINT32_MAX; ++i)
{
    header->nonce = i;
    calc_sha_256(block_hash, header, sizeof(block_header_t));

    if (memcmp(block_hash, target, sizeof(block_hash)) < 0)
        /* we found a good hash */
        return;
}
---

As you can imagine, this brute force operation
of adjusting numbers, and hashing again
can take a lot of CPU time!

### Timestamp

It's possible that the miner tries all the numbers that can be stored in a `uint32` (up to `4294967295`)
and never finds a valid hash.
This is what the **timestamp** field is for.
If all numbers have been tried,
the timestamp is reset and it starts again.

Here is the complete mining function:

--- mining
void mine_block(block_header_t* header)
{
    @{target}

    while (1)
    {
        /* MINING: start of the mining round */
        header->timestamp = (uint64_t)time(NULL); 

        @{nonce search}
 
        /* The uint32 expired without finding a valid hash.
           Restart the time, and hope that this time + nonce combo works. */
    }

    /* this should never happen */
    assert(0);
}
---

@s What will we store in the Blockchain?

In the real Bitcoin network, miners
are connected together in a peer-to-peer network.
They receive transactions from clients to include in blocks, and
share blocks that they produce, cooperatively building a chain.

Our tiny blockchain won't have any network or peers,
and will just run locally on a computer.
However we still want to get a real proof-of-work effect;
that longer chains have more CPU power spent on them.
So we need to pick a task that can run without user
intervention.

Our blockchain will simply take take lines of text and encode them in blocks,
as fast as it can.
This isn't very useful, but is still a good illustrative
example of how the chain works.
Storing text in the blocks actually follows Bitcoin tradition.
The [genesis block](https://en.bitcoin.it/wiki/Genesis_block).
includes a headline from a 2009 English newspaper.

![the times 2009](img/thetimes.jpg)

> "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"

We should follow the tradition and use it for our gensis block.

--- genesis block
printf("creating genesis block...\n");
char genesis_data[] = "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks";
block_header_t genesis = build_block(NULL, genesis_data, sizeof(genesis_data));
---

To keep our program simple, we can simply read text 
line by line from stdin and put each line in a block.
The block headers will be written into a file as they are mined.

--- input loop
int block_no = 0;
block_header_t previous = genesis;
while (!feof(stdin))
{
    /* hash the solved header. (only for display purposes) */
    uint8_t test_hash[32];
    calc_sha_256(test_hash, &previous, sizeof(block_header_t));
    printf("done. nonce: %i hash: ", previous.nonce);
    fprint_hash(stdout, test_hash);
    printf("\n");

    /* dump header to a file */
    fwrite(&previous, sizeof(block_header_t), 1, output_file);
 
    /* read data to put in the block */
    char line_buffer[LINE_MAX];
    fgets(line_buffer, LINE_MAX, stdin);  

    printf("creating block %i: ", block_no);
    printf("%s\n", line_buffer);
    uint64_t size = strnlen(line_buffer, LINE_MAX) + 1;
    block_header_t header = build_block(&previous, line_buffer, size);
  
    previous = header;
    ++block_no;
}
---

@s Utilties

The project is almost ready,
but we need a few more boring bits of code.
These are not relevant to understanding the actual blockchain.

--- print hashes
void fprint_hash(FILE* f, uint8_t* hash)
{
    fprintf(f, "0x");
    for (int i = 0; i < 32; ++i)
        fprintf(f, "%02x", hash[i]);
}
---

---blockchain.c

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <time.h>
#include <memory.h>
#include <assert.h>

#include "sha-256.h"

#define LINE_MAX 4096

@{print hashes}
@{block header}
@{mining}
@{build block}

int main(int argc, const char* argv[])
{
    FILE* output_file = fopen("chain.bin", "wb");

    @{genesis block}

    @{input loop}
    return 1;
}

---

At this point, you should have all the code to compile the project.
If you are not sure where something belongs, follow the references
or refer to the [final code](src/blockchain.c)

@s Running

I have provided [Plato's Gorgias](docs/data/gorgias.txt) as a sample text
to store in our Blockchain. Go ahead and download it.
Run the program by inputting the file to `stdin`.

    cat  ./gorgias.txt | ./blockchain 


    creating genesis block...
    done. nonce: 427455 hash: 0x000003e9ea9bb66eae1b34a4a1b482f3fcf0ee1ca0589ae16de8a6c9a410285f
    creating block 0: The Project Gutenberg EBook of Gorgias, by Plato

If the program produces blocks too slowly, or quickly, adjust the 
**target** variable.

@s Further Study

We have only just scratched the surface and there is much more to learn
to understand Bitcoin.
Here are a few topics to get you started.

### Merkle Trees

![merkle tree](img/merkle_tree.gif)

The block header in this project
is very close to the real [Bitcoin header](https://bitcoin.org/en/developer-reference#block-headers).

One difference however, is that instead of storing the hash of the entire contents. 
The root hash of a [Merkle Tree](https://en.bitcoinwiki.org/wiki/Merkle_tree)
is stored instead. 
This fullfills the same role, but makes it easy to check whether a given
transaction is included in a block.

### Mining

![asic miner inside](img/asic_miner.jpg)

"One CPU, one vote" no longer describes the mining process.
It has largely been overtaken by professional mining farms
so that individual computers cannot compete.

The most important factor in mining performance is how many
hashes you can produce in a second.
GPUs and special designed hardware called [ASICs](https://en.bitcoin.it/wiki/ASIC) can calculate
sha256 hashes far faster than CPUs.

Read [The State of Cryptocurrency Mining](https://blog.sia.tech/the-state-of-cryptocurrency-mining-538004a37f9b).

### Chain Reorginization

As I mentioned, Bitcoin miners create and share blocks in a peer-to-peer network.
A lot must go on to ensure peers stay connected, and new blocks
are spread throughout the network.

Due to network delays, two alternative tails to the chain may start
competing, and the network must resolve them.
See [Orphan Blocks](https://en.bitcoin.it/wiki/Orphan_Block).

A [large debate](https://en.bitcoin.it/wiki/Block_size_limit_controversy) in the Bitcoin community occured over the block size.
Larger blocks can store more transactions, and hence increase the speed of the chain,
but they also take longer to propogate around the internet.
This may limit Bitcoin participants to those with fast internet access,
or introduce more chain reorganizations, as blocks are slow to propogate.




