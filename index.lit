# Write your own POW Blockchain

https://bitcoin.org/en/developer-reference#block-headers
@code_type c .c
@comment_type /* %s */
@add_css main.css

@title Write your Own Proof-of-Work Blockchain

@s

By: [**Justin Meiners**](https://github.com/justinmeiners).

View the final code and other resources in the [GitHub repo](https://github.com/justinmeiners/tiny-blockchain).

@s Introduction

This article will teach you how to write a tiny proof-of-work blockchain,
focusing on the Bitcoin implementation.
I will emphasize "proof-of-work" because this is the key innovation of Bitcoin
that allows blockchains to store information in an "objectively" verifable way.

I wrote this mainly for programmers who are curious about how crypto currency works.
If you are a crypto currency enthusist you probably have seen article on the same topic.
I aim to make mine more clear and concise than those in the past.

This project will be written in C, although it should be easy to translate to other languages.
To start, create a new `blockchain.c` file to place the code in the article.
You will also need to include the files [sha-256.h](src/sha-256.h) and [sha-256.c](src/sha-256.c)(1) for
hashes (or use your language's library).

> **Note:** This is a [literate program](https://en.wikipedia.org/wiki/Literate_programming).
> This means you are reading the source code right now!
> The final output was created by ["weaving"](https://github.com/zyedidia/Literate) the blocks of code together.

@s What is a Blockchain?

A blockchain is a data structure for storing a sequence of records (**blocks**) in a tamper-resistant way.
It allows anyone to verify that records are in the right order and have not been modified.

This is made possible by cryptographic [hashes](https://en.wikipedia.org/wiki/Cryptographic_hash_function)
which map large pieces of data to short checksums.
The essential property of a hash is that its "one way".
It's easy to calculate output for an input, impossible to know
what input produced a given output, and
very difficult to find an alternative piece of data
that produces the same output.

(insert picture)

Each block is divided into a **header** and **contents**.
The contents are just arbitrary data.
The header contains some metadata about the block and two hashes:

1. The hash of the contents. This ensures that 
   anyone with the header can check that the contents
   do not change.

2. The hash of the previous block header.
   This ensures that anyone with the header
   can also check that *no preceding* block has changed.

Let's write a `struct` for storing the header:

--- block header
typedef struct
{
    // Length of the data in the block
    uint32_t contents_length;
    // Hash of the block contents.
    // Prevents contents from changing
    // (in Bitcoin this would actually be the "merkle root")
    uint8_t contents_hash[32];
    // prevents previous data from changing
    uint8_t previous_hash[32];

    // pow for later
    @{proof-of-work entries}
} block_header_t;

---

32 is then number of bytes in a `sha256` hash.

You may wonder how having the hash of the previous block
can protect against changes much earlier in the chain.
Remember that the previous block also has the hash of the header
*before it*, so any changes would changes to its header would affect
it, and so on in a cascading effect.

(insert picture)

Git version control is also based off this same idea.
Commits include hashes of their state of the code, and hashes
of the previous commit, so that repositories can ensure integrity.

## Creating Blocks

Creating a block is very straightfoward.
To make a new block we need some data for contents
and a reference to a previous block header (or `NULL` for the "genesis" block.)

We simply hash the contents and the previous block header and 
assign it to the new header.

--- build block

block_header_t build_block(const block_header_t* previous, const char* contents, uint64_t length)
{
    block_header_t header;
    header.contents_length = length;

    if (previous)
    {
        // calculate previous block header hash
        calc_sha_256(header.previous_hash, previous, sizeof(block_header_t));
    }
    else
    {
        // genesis has no previous. just use zeroed hash
        memset(header.previous_hash, 0, sizeof(header.previous_hash))
    }
    
    // add data hash
    calc_sha_256(header.contents_hash, contents, length);

    // mining. disucssed later
    mine_block(&header);
    return header;
}
---

@s What do you put into the blocks?

Blockchains can store any kind of data.
In this project we will just be storing binary blobs.
But, it can easily be modified to store other data.

Bitcoin of course stores [financial transactions](https://en.bitcoin.it/wiki/Transaction).
Instead of a hash of the whole block, the headers
have the [Merkle Root hash](https://en.bitcoinwiki.org/wiki/Merkle_tree),
which makes it easy to verify transactions are included in a block.
But, this is outside the scope of this project.

@s What is Proof of Work?

Blockchains can be useful record keeping devices among trusted groups, but its not clear
how they can keep any kind of contested record, especially a record that stores money.
If Alice doesn't have any block headers, then Bob can generate
a blockchain containing any records he wants, and give it to Alice.
She can verify its a proper blockchain, but how does she know it contains any records she cares about?

Even if Alice has all the block headers, she has no way to decide
which new blocks to add. All appear equally valid.

This is the problem solved by **proof-of-work**. 
It provides a simple rule that *anyone* can use to objectively (2) determine
whether a given blockchain is the one that is generally accepted. (3)

Intead of allowing blocks to be created freely,
proof-of-work requires that CPU resources be spent
in order to create a block. 

This is done by requiring that the hash of the block header
be less than some .
So a miner must continually modify the block
until it produces a hash that is smaller than a target.

But, the block header so far contains only immutable fields (the two hashes),
so we need to add a few more that the miner can tweak to try to
produce a different hash.

Add the following fiels to the `block_header_t` structure.

--- proof-of-work entries

// when this block started being mined
uint32_t timestamp; 

// nonce
// this is adjusted by the miner
// until a suitable hash is created
uint32_t nonce;
---

The `block_header_t` is now awfully close to the actual
[Bitcoin Header](https://bitcoin.org/en/developer-reference#block-headers)
with just a few simplifications.

--- mining

void mine_block(block_header_t* header)
{
    // set target
    // this is the difficulty
    uint8_t target[32];
    memset(target, 0, sizeof(target));
    target[2] = 0x1F;

    while (1)
    {
        // MINING
        // start of this mining round
        header->timestamp = (uint64_t)time(NULL);

        // adjust the nonce
        // until the block header is < the target hash
        uint8_t block_hash[32];

        for (uint32_t i = 0; i < UNIT32_MAX; ++i)
        {
            header->nonce = i;
            calc_sha_256(block_hash, header, sizeof(block_header_t));

            if (memcmp(block_hash, target, sizeof(block_hash)) == -1)
                // we found a good hash!
                return;
        }
        // we expired the uint32 without finding a valid hash
        // restart the time, and hope that this time + nonce
        // combo will work
    }

    // this should never happen
    assert(0);
}
---

So just to review. A valid block header is one
which has a hash less than the target hash.
To find one, a block producer adjusts the nonce,
until it hashes into the valid range.


@s Genesis Block

https://en.bitcoin.it/wiki/Genesis_block

![the times 2009](img/thetimes.jpg)


https://satoshi.nakamotoinstitute.org

--- genesis block
printf("creating genesis block...\n");
char genesis_data[] = "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks";
block_header_t genesis = build_block(NULL, genesis_data, sizeof(genesis_data));
---

@s Input Loop

--- input loop
block_header_t previous = genesis;
while (!feof(stdin))
{
    // ask for more data to put
    // in the next block
    printf("enter block data: \n");
    char line_buffer[LINE_MAX];
    fgets(line_buffer, LINE_MAX, stdin);  

    printf("creating block...\n");
    uint64_t size = strnlen(line_buffer, LINE_MAX) + 1;
    block_header_t header = build_block(&previous, line_buffer, size);

    // hash the resulting
    // header, for display purposes
    uint8_t test_hash[32];
    calc_sha_256(test_hash, &header, sizeof(block_header_t));

    printf("nonce: %i hash: ", header.nonce);
    fprint_hash(stdout, test_hash);
    printf("\n");
    
    previous = header;
}
---


@s Utilties


This section contains boring bits of code
not relevant to understanding the actual blockchain.

--- print hashes
void fprint_hash(FILE* f, uint8_t* hash)
{
    fprintf(f, "0x");
    for (int i = 0; i < 32; ++i)
        fprintf(f, "%02x", hash[i]);
}
---



---blockchain.c

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <time.h>
#include <memory.h>
#include <assert.h>

#include "sha-256.h"

#define LINE_MAX 2048

@{print hashes}
@{block header}
@{build block}
@{mining}

int main(int argc, const char* argv[])
{
    @{genesis block}

    @{input loop}

    // blocks aren't actually stored
    // anywhere. We just keep on building the chain
    // from the previous header.
    return 1;
}

---

@s Learning More


@s Notes



(1) - Thanks to [Alain Mosnier](https://github.com/amosnier/sha-2)
(2) - 
(3) - "Objectively" is being used a little loosely here. Of course, the objective
      reality is created an alter
(4) https://stackoverflow.com/questions/46192377/why-is-git-not-considered-a-block-chain
