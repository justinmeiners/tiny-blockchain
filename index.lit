# Write your Own Proof-of-Work Blockchain

By: [**Justin Meiners**](https://github.com/justinmeiners).

View the final code and other resources in the [GitHub repo](https://github.com/justinmeiners/tiny-blockchain).

Proof-of-work is the key innovation behind [Bitcoin](research/bitcoin.pdf) that allows the history of a piece of information to be recorded
and verified in an "objective way".
Embedded in the structure of a proof-of-work chain is evidence that a certain amount of computing power was consumed to produce it.
This allows anyone to verify its authenticity by examining the chain itself without requiring trust of third parties.

This article will introduce proof-of-work algorithms by writing a tiny blockchain 
in C closely following the [Bitcoin implementation](https://github.com/bitcoin/bitcoin).
It is intended to teach programmers who are curious to learn about cryptocurrency.
Cryptocurrency enthusiasts will be familiar with most of the material, but can benefit by seeing it work
in detail.

@toc

> **Note:** This tutorial is a [literate program](https://en.wikipedia.org/wiki/Literate_programming).
> This means you are reading the source code right now!
> The final output was created by ["weaving"](https://github.com/zyedidia/Literate) the blocks of code together.

## Hash functions

A **[hash function](https://en.wikipedia.org/wiki/Hash_function)** `h` is a mathematical function sending data of any length to data of a fixed length.
We often refer to the output data `h(x)` as a *hash* or *checksum* of the data `x`.
For example, Bitcoin uses the [sha256](https://en.wikipedia.org/wiki/SHA-2)
function which sends any binary data to a 256 bit hash.

![hash function](img/hash.png)

By definition hash functions cannot be one-to-one. 
There will be many inputs which produce the same output just because
there fewer outputs available and some [must double up](https://en.wikipedia.org/wiki/Pigeonhole_principle).
Consequently, if we are given a hash `y`, it's impossible to know exactly what input `x` it came from.
The best we could do is describe the collection of all inputs giving a particular output: `{ x | h(x) = y }`.

In the context of cryptography, we are particularly interested
in  [*one way* hashes](https://en.wikipedia.org/wiki/Cryptographic_hash_function).
These are hashes for which it is *easy* to calculate the output `h(x)` for a given input `x`
and *very difficult* to find an alternative piece of data that produces the same output.
In other words, we don't want to be able to easily find a `z /= x` where `h(z) = h(x)`.

**Exericse:** Give an example of a hash function (does not need to be cryptographic).

**Exercise:** Must a hash function map to every output multiple times?

**Exercise:** Learn about a hash function which was previously considered cryptographically secure which is no longer.

### Verification

Cryptographic hashes are very useful for verifying data, because
they are small, but also contain information about the full data.
Suppose a friend recommends you a new computer program.
How can you get the program, and ensure it's what he recommended and not a virus?

If your friend sent you the program himself, you could *trust him* directly.
Assuming that's not convenient,  he may have directed to a specific site to download it from, instead.
In this case he *trusts a third party* to provide you the correct file.

Alternatively, your friend could compute a hash of the file and send you that, since it would be much smaller than the full program.
You could then compute the hash of the file you downloaded, and then check if they match.
If they do, it's extremely likely that the program is authentic.
The alternative is that the provider crafted a different file that also hash the same hash,
which cryptographic hash functions make very hard to do.

This is exactly what makes [BitTorrent](https://en.wikipedia.org/wiki/BitTorrent) work.
If you download something like Ubuntu Linux you first obtain a hash from the team of trusted developers.
You can then safely download the data from anywhere else on the internet (assuming that hash was correct).

## Hashing histories 

Hashes are helpful for recording and verifying the *state* of data at a fixed snapshot in time.
But sometimes, we want to record and verify the *history* of some data over time.
Two pieces of data may look the same now, but might not be equivalent 
if two different paths were taken to get there.
In physics and math, this property is called [path dependence](https://en.wikipedia.org/wiki/Nonholonomic_system):

![path dependence](img/path-dependence.png)

A bank account is one such example.
We not only care about the final balance, but the full history of each deposit and withdrawal.
Did our bills get paid?
Has someone been withdrawing money from our account?
Path dependence is starting to sound pretty important!

Recording hashes of a bank balance would not be very useful for verifying it's authenticity.
Whenenver the balance changes the hash would also change, whether due to authentic
transactions or manipulation.
What would be more useful is to record and hash the history of transactions over a period of time.
Then in future bank statements you could check those ranges against the hash.

This scheme works pretty well for bank accounts, but it's a bit harder to generalize to other kinds of data.
For example, we can't always organize the full data neatly into a time window. 
What we need is to generalize these ideas,
leading to the concept of a blockchain.

### Blockchains

A **blockchain** is an ordered sequence of records called **blocks**.
Each block is made up of a **header** and **contents**.
The **contents** is arbitary data to be stored in the chain.
The **header** contains some metadata about the block, along with two hashes:

1. The hash of the contents.

2. The hash of the previous block header (or 0 if there is none).

--- block header
typedef struct
{
    /* Length of the data in the block */
    uint32_t contents_length;
    /* Hash of the block contents. */
    /* 32 is the number of bytes in a sha256 hash */
    uint8_t contents_hash[32];
    uint8_t previous_hash[32];
} block_header_t;
---

The use of the first hash is obvious. 
To check whether some data is in our chain,
 take its hash, and try to find a header with that contents hash.
The headers tend to be much smaller than the blocks, so sharing headers isn't a burden.

But, the second hash is the really intersting part. 
It hashes the previous header, and since the previous does similarly,
in a weird way it is a hash of all the blocks in the chain so far.
This can be used to ensure no additional blocks can be inserted, or removed, and no history is modified.

![blockchain](img/blockchain.gif)

Another way to see this "domino" effect is by thinking of the blockchain as a recursive definition.
Let `H_i` be the hash of the `i`th block header and `C_i` be the hash of it's contents. 
Then `H_n` is defined in the following way:

    H_1 = h(0 + C_1))
    H_n = h(H_{n-1} + C_n)

If we expand, this definition for a specific case like `H_4`, we see it includes the conents hash of all previous blocks:

    H_4 = h(h(h(h(0 + C_1) + C_2) + C_3) C_4)


Essentially a blockchain is a linked list, but with additional cryptographic information,
that makes the chain, and it's contents, tamper resistant.
Given some small header information, one can verify whether a given record:

1. Belongs in the sequence.
2. Is in the correct order, relative to the other records.

### Adding blocks

Creating a block and adding it to the chain is straightforward.
The arguments include a reference to a previous block header (or `NULL` for the initial "genesis block"),
but not any of the previous contents.
We simply hash the new contents and the previous block header and assign it to the new header.

We need one dependency: [sha-256.h](src/sha-256.h) and [sha-256.c](src/sha-256.c)
which provides the hash function `calc_sha_256`.


--- build block
block_header_t build_block(const block_header_t* previous, const char* contents, uint64_t length)
{
    block_header_t header;
    header.contents_length = length;

    if (previous)
    {
        /* calculate previous block header hash */
        calc_sha_256(header.previous_hash, previous, sizeof(block_header_t));
    }
    else
    {
        /* genesis has no previous. just use zeroed hash */
        memset(header.previous_hash, 0, sizeof(header.previous_hash));
    }
    
    /* add data hash */
    calc_sha_256(header.contents_hash, contents, length);
    return header;
}
---


## Proof-of-work

The headers of a blockchain allow you to verify that any contents of the chain are valid, even if you don't have them.
And, the headers tend to be a lot smaller than the original data,
so you don't need to store much to get that ability.
So that's all really cool, but this is still a long ways away from being able to perform financial transactions securely.

The main problem, is how to get the valid headers in the first place.
Some financial transactions can be stored in a valid blockchain, but how do you know those transacations are correct?
A malicious person could modify some contents, update the chain, and you would have no way to tell they weren't *genuine*.
At some point, you need to obtain headers from a trusted party.
At that point, why can't you just trust the third party to give you the data as well?

So, blockchains don't automatically make a record trustworthy, but they can be useful record-keeping tools among trusted parties.
The [Git](https://git-scm.com/) version control system appeared before Bitcoin, and uses a blockchain just like this!
It stores each change to a set of files in a block called a commmit.
The commit includes a hash of the state of the files combined with the hash of the previous commit.
If the contents of an old commit are modified, all future commits must also change.
But, at the end of the day, you Git repositories are shared between trusted parties.

### Mining

The challenge posed by Bitcoin is to store a record of financial transactions that complete strangers can agree on.
Internet money shouldn't require entrusting funds to another person!
What it needs is a simple rule that anyone can use to "objectively" determine whether a given blockchain is the "right" one.
This is the problem solved by **proof-of-work**. 

Instead of allowing blockchains to be created freely, proof-of-work requires that computing resources be spent on a time-consuming problem 
for each block of the chain, in a process calleed **mining**.
To **mine** a block, a computer is given a difficult search problem, to find an answer for.
It searches, and searches, using compute power, and after some time hopefully finds an answer.
This answer is then included in the block itself providing verifiable proof to everyone, that the work was done.
Hence the term "proof-of-work."

#### Nonce


Turning a regular old blockchain into a proof-of-work blockchain is suprisingly easy.
We just need one additional rule for a chain to be valid.
We require the *hash of any block header must to be less than some **target** hash*.
By "less than" we mean the usual [byte by byte](https://en.cppreference.com/w/c/string/byte/memcmp) lexicographic comparison
(for example `0000 0001 < 0000 0010`).

From what we have discussed so far, this is a strange requirement. 
Hashes don't have any ordering requirements and the hashes
are entirely determined by the contents and the chain.
So what does this do?

First, let's add a mechanism so that the hash of a header can be changed, without hurting he actual data.
One way to do this is to add a number called a **nonce** to the block header.
If we don't like the header's hash, we can change it, simply by changing the nonce.

In order to satisfy our new proof-of-work requirement we specifically want as hash below the target range.
So, we just keep trying nonces, changing the hash, until we get one in the target range.
to try to get the hash into the target range.
Searching for a valid nonce can take some time and is the "difficult search problem" we described above.
There is no rhyme or reason to guessing the nonce.
We just try as many as we can!

Let's redefine our header, and add a `timestamp` and `nonce`.

--- block header :=
typedef struct
{
    /* Length of the data in the block */
    uint32_t contents_length;
    /* Hash of the block contents. */
    /* 32 is the number of bytes in a sha256 hash */
    uint8_t contents_hash[32];
    uint8_t previous_hash[32];

    /* when this block started being mined */
    uint32_t timestamp; 

    /* This is adjusted to make the hash of this header fall in the valid range. */
    uint32_t nonce;
} block_header_t;
---

Then let's write a loop that tests numbers in order, until we find a valid hash:

--- nonce search
/* adjust the nonce until the block header is < the target hash */
uint8_t block_hash[32];

for (uint32_t i = 0; i < UINT32_MAX; ++i)
{
    header->nonce = i;
    calc_sha_256(block_hash, header, sizeof(block_header_t));

    if (memcmp(block_hash, target, sizeof(block_hash)) < 0)
        /* we found a good hash */
        return;
}
---

As you can imagine, this brute force operation of adjusting numbers, and hashing again can take a lot of CPU time!

### Timestamp

It's possible that the miner tries all the numbers that can be stored in a `uint32` (up to `4294967295`) and never finds a valid hash.
This is what the **timestamp** field is for.
If all numbers have been tried, the timestamp is reset to the current time, and the process starts again.

Here is the complete mining function with time reset:

--- mining
void mine_block(block_header_t* header, const uint8_t* target)
{
    while (1)
    {
        /* MINING: start of the mining round */
        header->timestamp = (uint64_t)time(NULL); 

        @{nonce search}
 
        /* The uint32 expired without finding a valid hash.
           Restart the time, and hope that this time + nonce combo works. */
    }

    /* this should never happen */
    assert(0);
}
---

### Target

We haven't talked about how the target hash is chosen. 
Any hash can be used.
 However, the smaller (in ordering) it is, the more difficult it is to find a valid hash,
as there are fewer hashes within the valid range.

In our project, we will use a constant target.


In Bitcoin, the target actually changes with each block.
This allows bitcoin to adjust the [mining difficulty](https://en.bitcoin.it/wiki/Difficulty)
in order to regulate the speed of block production as computers get faster and faster.


**Exercise:** Describe a method of adjusting the target based on changing mining effort,
that will e, in a manner which leads to

## Objectivity

Let's review what mining does for us.
First, it allows us to control the rate at which valid blocks can be produced.
Computers can only search for nonces so fast, and by adjusting the target, we can get a pretty
good limit on the rate of production.

In the context of Bitcoin, we want to make a ledge of transactions which can be shared by people around the internet.
We need to set a hard cap on the rate that transactions are produced, in order to allow
data to be sent across the interent, and everyone to stay in sync.

More importantly, mining gives us an objective way to verify whether a chain is valid.
Note that the hash being in a valid range is mathematical property, that can't be faked.
If we find a header that has such a hash, we know it was either a very lucky
or computing resources were spent in order to find a nonce to make it valid.
We can determine this objectively, by looking at the chain itself.
Furthmore, *longer chains have had more computing resources spent making them.*

In the Bitcoin network computers across the world are constantly racing to be the first to find a valid hash, and mine a new block.
They receive a financial reward for producing the next valid block (hence the mining analogy).
Since this has been going non-stop since it's initial launch in 2009, the Bitcoin blockchain has had *a lot* of computing resources spent on it.
To create a valid chain just as long, with as much proof of work, would require redoing all that computing work.
This is what makes the chain verifiable.
The valid Bitcoin chain is always *the one that is the longest* because it is the one that has had the most mining effort spent on it.

> "Bitcoin can thus be understood as a technology that converts electricity to truthful records through the expenditure of processing power." - Safedean Ammous.

### Voting

At any snapshot in time, determining the longest chain is slightly more complicated then this.
New blocks are regularly being mined, and it's possible that two ore more valid blocks
are created at around the same time. 
At this point the chain forks, and we have two equally long chains to choose from.

![fork](img/fork.png)

However, as soon as a new block is added, miners are already rushing to create the next one.
They have to decide which of these paths to start working one, as the valid nonce will only work for one of them.
At this time, the pick one, and by doing so, they essentially vote on which path is the future.
Miners are incentivized to come to consensues quickly, as they need their work to be included in the valid chain,
in order to spend their rewards.

Overtime, brief forks occur, but quickly resolve and short [orphans](https://en.bitcoin.it/wiki/Orphan_Block)
are abandoned.
In practice, only the very latest blocks face this contention and potential to be rejected.
Blocks included much earlier have so much proof-of-work on top of them, that changing them
is practically impossible.

![chain reorganization](img/reorg.png)

> "Proof-of-work is essentially one-CPU-one-vote.
> The majority decision is represented by the longest chain, which has the greatest proof-of-work effort invested in it." - Satoshi Nakamoto

Proof-of-work also makes it very difficult to tamper with old records or produce a fraudulent chain.
To rewrite a block, you have to spend the CPU resources to do so.
To go back two blocks requires double the amount of work, and so on.
Meanwhile, the original chain is constantly being extended by CPUs across the globe.
So not only would an attacker have to redo all the work that has been done, but it would have to do it faster than the rest of the Bitcoin network creates new blocks.

I put the words "objectively" and "right" in quotes because you now know they are a bit dubious.
The "right" chain is defined by the consensus of CPU power.
A group or individual who wields a lot of CPU power can change the consensus.
The right blockchain is the one that the most mining power has been put into.
The only objective thing we can determine is if one chain has had more CPU resources spent on it than another.
It is certainly a clever system, with carefully structured incentives, but it has limitations.

## Storing data

The Bitcoin blockchain stores a ledger of [financial transactions](https://en.bitcoin.it/wiki/Transaction)
each referencing previously deposited amounts and transferring them to new addresses.
A lot of the Bitcoin code is dedicated to the network protocol for accepting transactions, broadcasting them, and syncing the state of the chain
across the internet.
All of this is interesting stuff, but not necessary to understand proof of work.

To keep things simple, our blockchain will just run locally on a computer.
However, we still want a real proof-of-work effect; that longer chains have more work spent on them.
We will demonstrate this by taking lines from a text file, encoding each of them in blocks,
and appending them onto a growing chain, as fast as possible.
This isn't very useful, but it is still a good illustration of the constant production of blocks on the Bitcoin network.

Storing text in blocks does follow Bitcoin tradition.
The [genesis block](https://en.bitcoin.it/wiki/Genesis_block) curiously includes this headline from a 2009 English newspaper:

> "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"

![the times 2009](img/thetimes.jpg)




We will follow the tradition and include it for our genesis block.

opening and closing files is always a pain, so we will just follow UNIX fashion,
and 

So we don't have to worry about finding files to read, the program will read text line by line from stdin and put each line in a block.
The block headers will be written into a file as they are mined.

--- input loop

int block_no = 0;
block_header_t previous;

while (!feof(stdin))
{
    /* read data to put in the block */
    char line_buffer[LINE_MAX];
    fgets(line_buffer, LINE_MAX, stdin);  
    uint64_t size = strnlen(line_buffer, LINE_MAX) + 1;


    block_header_t* previous_ptr = block_no == 0 ? NULL : &previous;
    fprintf(stderr, "creating block %i: ", block_no);
    fprintf(stderr, "%s\n", line_buffer);
     
    block_header_t header = build_block(previous_ptr, line_buffer, size);
    mine_block(&header, target);
    previous = header;
    ++block_no;

    /* hash the solved header. (only for display purposes) */
    printf("previous: ");
    fprint_hash(stdout, previous.previous_hash);
    printf("\n");

    printf("contents: ");
    fprint_hash(stdout, previous.contents_hash);
    printf("\n");

    printf("timestamp: %d\n", previous.timestamp);
    printf("nonce: %d\n", previous.nonce);

    uint8_t test_hash[32];
    calc_sha_256(test_hash, &previous, sizeof(block_header_t));
    printf("hash: ");
    fprint_hash(stdout, test_hash);
    printf("\n\n\n");

}
---

## Utilities

The project is almost ready, but we need a few more boring bits of code.
These are not relevant to understanding the actual blockchain.

--- print hashes
void fprint_hash(FILE* f, uint8_t* hash)
{
    fprintf(f, "0x");
    for (int i = 0; i < 32; ++i)
        fprintf(f, "%02x", hash[i]);
}
---

--- /blockchain.c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <time.h>
#include <memory.h>
#include <assert.h>

#include "sha-256.h"

#define LINE_MAX 4096

@{print hashes}
@{block header}
@{mining}
@{build block}

/* this controls the difficulty.
   I chose this target because it works well on my computer.
   Feel free to try out others. */

uint8_t target[32];

int main(int argc, const char* argv[])
{
    memset(target, 0, sizeof(target));

    /* too hard?: try target[2] = 0xFF
       too easy?: try target[2] = 0x01 */
    target[2] = 0x0F;

    @{input loop}
    return 1;
}

---

At this point, you should have all the code to compile the project.
If you are not sure where something belongs, follow the references or refer to the [final code](src/blockchain.c)

## Running the program

I have provided [Plato's Gorgias](docs/data/gorgias.txt) as a sample text to store in our blockchain. Go ahead and download it.
Run the program by inputting the file to `stdin`.

    cat  ./gorgias.txt | ./blockchain 

    creating genesis block...
    done. nonce: 427455 hash: 0x000003e9ea9bb66eae1b34a4a1b482f3fcf0ee1ca0589ae16de8a6c9a410285f
    creating block 0: The Project Gutenberg EBook of Gorgias, by Plato

If the program produces blocks too slowly, or quickly, adjust the  variable.

## Further study

We have only just scratched the surface, and there is much more to learn from Bitcoin.
You will certainly want to read the original whitepaper.
Here are a few topics to get you started.

### Merkle trees

![Merkle tree](img/merkle_tree.gif)

The block header we wrote above closely matches the real [Bitcoin header](https://en.bitcoin.it/wiki/Protocol_documentation#Block_Headers).
One difference is that instead of storing a contents hash, the root hash of a [Merkle tree](https://en.bitcoinwiki.org/wiki/Merkle_tree) is stored instead. 
The Merkle hash fulfills the same role of verifying the contents, and it also makes it easier to check whether an individual transaction is in the block.

### Mining

![asic miner inside](img/asic_miner.jpg)

"One CPU, one vote" no longer describes the mining process.
It has largely been overtaken by professional mining farms so that individual computers cannot compete.

The most important metric in mining performance is how many hashes you can produce in a second.
GPUs and specially designed hardware called [ASICs](https://en.bitcoin.it/wiki/ASIC) can calculate sha256 hashes far faster than CPUs.

Read [The State of Cryptocurrency Mining](https://blog.sia.tech/the-state-of-cryptocurrency-mining-538004a37f9b).
Should we return to "One CPU, one vote"?
Is it even [possible](https://hackernoon.com/asic-resistance-is-nothing-but-a-blockchain-buzzword-b91d3d770366)?

### Chain reorginization


(Image thanks to [Nakamoto Institute](https://nakamotoinstitute.org/about/))

As I mentioned, Bitcoin miners create and share blocks in a peer-to-peer network.
A lot must happen to ensure peers stay connected and that new blocks are spread throughout the network.
Due to network delays, several alternative tails may form and start competing to be the longest.
The nodes will follow a few of these until a clear winner arises.
See .

A [major debate](https://en.bitcoin.it/wiki/Block_size_limit_controversy) in the Bitcoin community occurred over the block size and resulted in the fork of Bitcoin Cash.
Large blocks can store more transactions, and hence increase the speed of the chain, but they also take longer to propagate around the internet.
This may restrict Bitcoin participants to only those with fast internet access (like data centers), or introduce more chain reorganizations as blocks become slower to propagate.

### Economic incentives

Why do miners [mine](https://blog.sia.tech/fundamentals-of-proof-of-work-beaa68093d2b)?
Why should they [include transactions](https://en.bitcoin.it/wiki/Miner_fees) from individuals in the chain?
Do [miners control](https://en.bitcoin.it/wiki/Bitcoin_is_not_ruled_by_miners) the chain?
Does Bitcoin really eliminate the costs of transaction enforcement?
How could someone disrupt Bitcoin?

These are all great questions to learn about, but you may have a harder time finding reliable information.

### Acknowledgements

Special thanks to my reviewers for editing and feedback:

- [Derek McDaniel](https://github.com/derekmc)
- [Hunter Rasmussen](https://github.com/HunterRasmussen)
- [Ryan Pendleton](https://github.com/rpendleton)
